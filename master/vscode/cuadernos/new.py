    "import random\n",
    "\n",
    "# Número de ciudades\n",
    "n = 16  # Ajusta el número de ciudades según tu problema\n",
    "# Parmetros del algoritmo genético\n",
    "Sc = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]\n",
    "tamano_poblacion = 10\n",
    "\n",
    "probabilidad_mutacion = 0.04\n",
    "indx = 0\n",
    "num_generaciones = 0\n",
    "xx = n-1\n",
    "longitud_cromosoma= int(np.round(np.log2(np.math.factorial(xx))))\n",
    "\n",
    "# Inicializar la población\n",
    "poblacion = generar_poblacion(tamano_poblacion, longitud_cromosoma)\n",
    "\n",
    "\n",
    "# Función para generar una población inicial\n",
    "def generar_poblacion(tamano_poblacion, longitud_cromosoma):\n",
    "    return [''.join(random.choice('01') for _ in range(longitud_cromosoma)) for _ in range(tamano_poblacion)]\n",
    "\n",
    "# Función para evaluar la aptitud de un individuo\n",
    "def evaluar_aptitud(cromosoma):\n",
    "    # Paso 1: Convertir el cromosoma en un número decimal v\n",
    "    v = int(cromosoma, 2)\n",
    "    \n",
    "    # Paso 2: Asignar a c el número de ciudades menos 1\n",
    "    c = n - 1\n",
    "    \n",
    "    # Inicializar el vector S\n",
    "    S = [] \n",
    "    \n",
    "    # Evaluar la aptitud\n",
    "    ias=0\n",
    "    while c > 0:\n",
    "        # Paso 3: Hallar el resto de la división entre v y c y añadírselo al vector S\n",
    "        resto = v % c\n",
    "        S.append(resto)\n",
    "        \n",
    "        # Paso 4: Asignarle a v el resultado entero de la división entre v y c\n",
    "        v = v // c\n",
    "        \n",
    "        # Paso 5: Restarle 1 a c\n",
    "        c -= 1\n",
    "    \n",
    "    # Paso 6: Si c es mayor que 1, volver al Paso 3\n",
    "    Sn = []\n",
    "    Scaux = Sc.copy()\n",
    "   \n",
    "    for posicion in S:\n",
    "        \n",
    "        valor_seleccionado = Scaux.pop(posicion)\n",
    "        Sn.append(valor_seleccionado)\n",
    "    for ciudad in Scaux:\n",
    "        if not ciudad in Sn:\n",
    "            #Sn.append(ciudad)\n",
    "            Sn.insert(random.randint(0, n-1), ciudad)\n",
    "    \n",
    "             \n",
    "    aptitud = calcular_distancia_total(Sn)\n",
    "    \n",
    "    return aptitud\n",
    "\n",
    "# Función para calcular la distancia total recorrida (por ejemplo)\n",
    "def calcular_distancia_total(individuo):\n",
    "    # Aquí implementa el cálculo de la distancia total basado en el vector S\n",
    "        ciudad_actual = individuo[0]  # Obtén la primera ciudad \n",
    "        distancia_total = 0\n",
    "\n",
    "        for i in range(1, 15):\n",
    "            siguiente_ciudad = individuo[i]\n",
    "           \n",
    "            distancia_total += datos[ciudad_actual-1][siguiente_ciudad-1]\n",
    "            ciudad_actual = siguiente_ciudad\n",
    "\n",
    "        # Regresa a la ciudad de inicio\n",
    "        distancia_total += datos[ciudad_actual-1][individuo[0]-1]\n",
    "        print(f\"Distancia: {distancia_total}  mejor solución: {individuo}\")\n",
    "        return distancia_total\n",
    "\n",
    "\n",
    "    \n",
    "\n",
    "def seleccionar_individuo_ruleta(poblacion, aptitudes):\n",
    "    total_aptitud = sum(aptitudes)\n",
    "    probabilidad = [aptitud / total_aptitud for aptitud in aptitudes]\n",
    "    return random.choices(poblacion, probabilidad)[0]\n",
    "\n",
    "def seleccionar_individuo_torneo(poblacion, aptitudes):\n",
    "    k=10\n",
    "    selected_population = []\n",
    "    population_size = len(poblacion)\n",
    "    \n",
    "    for _ in range(population_size):\n",
    "        tournament = random.sample(range(population_size), k)  # Selecciona 'k' individuos al azar para el torneo\n",
    "        winner = min(tournament, key=lambda i: aptitudes[i])  # Elige al individuo con la menor aptitud en el torneo\n",
    "        selected_population.append(poblacion[winner])\n",
    "    \n",
    "    return selected_population\n",
    "\n",
    "def tournament_selection(population, fitness_values):\n",
    "    selected_parents = []\n",
    "    k = 5\n",
    "    num_parents = 2\n",
    "    for _ in range(num_parents):\n",
    "        tournament = random.sample(range(len(population)), k)\n",
    "        winner = max(tournament, key=lambda i: fitness_values[i])\n",
    "        selected_parents.append(population[winner])\n",
    "\n",
    "    return selected_parents\n",
    "\n",
    "\n",
    "\n",
    "def find_best_individual(population, fitness_values):\n",
    "    # Encontrar y registrar al mejor individuo en la población.\n",
    "    best_index = fitness_values.index(min(fitness_values))\n",
    "    best_individual = population[best_index]\n",
    "    \n",
    "    return best_individual\n",
    "\n",
    "def replace_worst_with_best(population, fitness_values, best_individual):\n",
    "    # Encontrar el peor individuo y sustituirlo por el mejor individuo si es superior.\n",
    "    worst_index = fitness_values.index(min(fitness_values))\n",
    "    if evaluar_aptitud(best_individual) > fitness_values[worst_index]:\n",
    "        population[worst_index] = best_individual\n",
    "    \n",
    "def cruzamiento_un_punto(padre1, padre2):\n",
    "    punto_cruzamiento = random.randint(1, 40)  # Se elige un punto de cruzamiento aleatorio (excepto el primer y último bit)\n",
    "    \n",
    "    hijo1 = padre1[:punto_cruzamiento] + padre2[punto_cruzamiento:]\n",
    "    hijo2 = padre2[:punto_cruzamiento] + padre1[punto_cruzamiento:]\n",
    "    \n",
    "    return hijo1, hijo2\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Función para aplicar la mutación a un individuo\n",
    "def mutar_individuo(individuo):\n",
    "    mutado = list(individuo)\n",
    "    for i in range(len(individuo)):\n",
    "        if random.random() < probabilidad_mutacion:\n",
    "            # Cambia el bit si la probabilidad de mutación se cumple\n",
    "            mutado[i] = '0' if individuo[i] == '1' else '1'\n",
    "    return ''.join(mutado)\n",
    "\n",
    "# Aplicar mutación a la población después del cruzamiento\n",
    "nueva_poblacion_despues_mutacion = [mutar_individuo(individuo) for individuo in nueva_poblacion_despues_cruzamiento]\n",
    "def convmejor(cromosoma):\n",
    "   # Paso 1: Convertir el cromosoma en un número decimal v\n",
    "    v = int(cromosoma, 2)\n",
    "    \n",
    "    # Paso 2: Asignar a c el número de ciudades menos 1\n",
    "    c = n - 1\n",
    "    \n",
    "    # Inicializar el vector S\n",
    "    S = [] \n",
    "    \n",
    "    # Evaluar la aptitud\n",
    "    ias=0\n",
    "    while c > 0:\n",
    "        # Paso 3: Hallar el resto de la división entre v y c y añadírselo al vector S\n",
    "        resto = v % c\n",
    "        S.append(resto)\n",
    "        \n",
    "        # Paso 4: Asignarle a v el resultado entero de la división entre v y c\n",
    "        v = v // c\n",
    "        \n",
    "        # Paso 5: Restarle 1 a c\n",
    "        c -= 1\n",
    "    \n",
    "    # Paso 6: Si c es mayor que 1, volver al Paso 3\n",
    "    Sn = []\n",
    "    Scaux = Sc.copy()\n",
    "    \n",
    "    for posicion in S:\n",
    "    \n",
    "        valor_seleccionado = Scaux.pop(posicion)\n",
    "        Sn.append(valor_seleccionado)\n",
    "    \n",
    "    for ciudad in Scaux:\n",
    "        if not ciudad in Sn:\n",
    "            #Sn.append(ciudad)\n",
    "            Sn.insert(random.randint(0, n-1), ciudad)   \n",
    "    \n",
    "    return Sn\n",
    "\n",
    "# Algoritmo genético\n",
    "while indx < 1:\n",
    "    # Evaluación de aptitud\n",
    "    aptitudes = [evaluar_aptitud(cromosoma) for cromosoma in poblacion]\n",
    "    mejor_individuo = find_best_individual(poblacion, aptitudes)\n",
    "    # Selección\n",
    "    nueva_poblacion = []\n",
    "\n",
    "    \n",
    "    for _ in range(tamano_poblacion // 2):\n",
    "        padre1 = seleccionar_individuo_ruleta(poblacion, aptitudes)\n",
    "        padre2 = seleccionar_individuo_ruleta(poblacion, aptitudes)\n",
    "\n",
    "        hijo1, hijo2 = cruzamiento_un_punto(padre1, padre2)\n",
    "        nueva_poblacion.extend([hijo1, hijo2])\n",
    "    \n",
    "    #for _ in range(tamano_poblacion // 2):\n",
    "        #selected_parents = tournament_selection(poblacion, aptitudes)\n",
    "        #hijo1, hijo2 = cruzamiento_un_punto(selected_parents[0], selected_parents[1])\n",
    "        #nueva_poblacion.extend([hijo1, hijo2])\n",
    "    # Mutación\n",
    "    nueva_poblacion = [mutar_individuo(individuo) for individuo in nueva_poblacion]\n",
    "    \n",
    "    # Reemplazar la población anterior con la nueva población\n",
    "    poblacion = nueva_poblacion\n",
    "    poblacion[aptitudes.index(max(aptitudes))] = mejor_individuo\n",
    "    #replace_worst_with_best(poblacion, aptitudes, mejor_individuo)\n",
    "     \n",
    "    # Mostrar la aptitud del mejor individuo en esta generación \n",
    "    aptitudes = [evaluar_aptitud(cromosoma) for cromosoma in poblacion]\n",
    "    mejor_individuo_generacion = poblacion[aptitudes.index(min(aptitudes))]\n",
    "    mejor_aptitud_generacion = min(aptitudes)\n",
    "    if(num_generaciones % 10000 == 0): # Every 1 epochs\n",
    "\n",
    "                \n",
    "        print(f\"Generación {num_generaciones}: Mejor individuo - {mejor_individuo_generacion}, Aptitud: {mejor_aptitud_generacion} mejor solucion: {convmejor(mejor_individuo_generacion)}\")\n",
    "    if mejor_aptitud_generacion < 5500 or num_generaciones == 200000: indx += 1\n",
    "    num_generaciones += 1\n",
    "print(f\"mejor solucion: {convmejor(mejor_individuo_generacion)} Aptitud: {mejor_aptitud_generacion}\")"